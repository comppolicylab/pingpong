name: Push New Release to AWS
run-name: "${{ github.event.release.prerelease && 'Staging' || 'Production' }}: Release ${{ github.event.release.tag_name }} on AWS"
concurrency: release

on:
  release:
    types: [published, released]

jobs:
  release:
    name: Build and Push/Tag Docker Images for Release
    timeout-minutes: 20
    runs-on: ubuntu-latest
    steps:
      - name: Checkout release code at tag commit
        uses: actions/checkout@v6
        with:
          fetch-depth: 0

      - name: Parse version tag
        run: |
          RELEASE_TAG="${{ github.event.release.tag_name }}"

          # Validate semver format: vX, vX.Y, or vX.Y.Z (with optional prerelease)
          if [[ ! "$RELEASE_TAG" =~ ^v([0-9]+)(\.([0-9]+))?(\.([0-9]+))?(-[0-9A-Za-z-]+(\.[0-9A-Za-z-]+)*)?$ ]]; then
            echo "Error: Invalid tag format. Expected: vX, vX.Y, or vX.Y.Z"
            echo "Got: $RELEASE_TAG"
            exit 1
          fi

          # Extract parts
          VERSION="${RELEASE_TAG#v}"
          PRERELEASE=""
          if [[ "$VERSION" =~ -(.+)$ ]]; then
            PRERELEASE="-${BASH_REMATCH[1]}"
            VERSION="${VERSION%%-*}"
          fi

          # Normalize to X.Y.Z
          IFS='.' read -ra PARTS <<< "$VERSION"
          MAJOR="${PARTS[0]:-0}"
          MINOR="${PARTS[1]:-0}"
          PATCH="${PARTS[2]:-0}"
          NORMALIZED="${MAJOR}.${MINOR}.${PATCH}${PRERELEASE}"

          echo "IMAGE_VERSION=$RELEASE_TAG" >> $GITHUB_ENV
          echo "VERSION_STRIPPED=$NORMALIZED" >> $GITHUB_ENV
          echo "Parsed version: $RELEASE_TAG -> $NORMALIZED"
        shell: bash

      - name: Compute RELEASE_VERSION for Sentry
        shell: bash
        run: |
          # Sentry release format: pingpong@X.Y.Z
          SHORT_SHA=$(git rev-parse --short HEAD)
          RELEASE_VERSION="pingpong@${VERSION_STRIPPED}+${SHORT_SHA}"
          echo "RELEASE_VERSION=$RELEASE_VERSION" >> $GITHUB_ENV
          echo "Computed RELEASE_VERSION=$RELEASE_VERSION for Sentry"

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@6ebc88dc2e550247a73cd8cbf189bbc7fd61c3b4
        with:
          aws-access-key-id: ${{ secrets.PINGPONG_AWS_ACCESS_KEY }}
          aws-secret-access-key: ${{ secrets.PINGPONG_AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ vars.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@d63b14614fe5d7fc5e5e52c523dea4e876816cc4

      - name: Get Registry ID
        run: |
          REGISTRY_ID="${{ vars.PINGPONG_REGISTRY_ENDPOINT }}"
          REGISTRY_ID=${REGISTRY_ID%%.*}
          echo "REGISTRY_ID=$REGISTRY_ID" >> $GITHUB_ENV

      - name: Check if Server image exists
        env:
          ENVIRONMENT: ${{ github.event.release.prerelease && 'stage' || 'prod' }}
        run: |
          # Check if the image with version tag exists
          if aws ecr describe-images --repository-name ${{ vars.PINGPONG_SRV_REPO }} --registry-id ${{ env.REGISTRY_ID }} --image-ids imageTag=${{ env.IMAGE_VERSION }} >/dev/null 2>&1; then
            if grep -q ${{ env.ENVIRONMENT }} <<< $(aws ecr describe-images --repository-name ${{ vars.PINGPONG_SRV_REPO }} --registry-id ${{ env.REGISTRY_ID }} --image-ids imageTag=${{ env.IMAGE_VERSION }}); then
              echo "SRV_IMAGE_STATUS=EXISTS_WITH_ENV_TAG" >> $GITHUB_ENV
              echo "Server Image with tag ${{ env.IMAGE_VERSION }} exists and has the ${{ env.ENVIRONMENT }} tag in ECR."
            else
              echo "SRV_IMAGE_STATUS=EXISTS_WITHOUT_ENV_TAG" >> $GITHUB_ENV
              echo "Server Image with tag ${{ env.IMAGE_VERSION }} exists but does not have the ${{ env.ENVIRONMENT }} tag in ECR."
            fi
          else
            echo "SRV_IMAGE_STATUS=DOES_NOT_EXIST" >> $GITHUB_ENV
            echo "Server Image with tag ${{ env.IMAGE_VERSION }} does not exist in ECR."
          fi
        shell: bash

      - name: Tag server image for release
        env:
          ENVIRONMENT: ${{ github.event.release.prerelease && 'stage' || 'prod' }}
        if: ${{ env.SRV_IMAGE_STATUS == 'EXISTS_WITHOUT_ENV_TAG' }}
        run: |
          MANIFEST=$(aws ecr batch-get-image --repository-name ${{ vars.PINGPONG_SRV_REPO }} --registry-id ${{ env.REGISTRY_ID }} --image-ids imageTag=${{ env.IMAGE_VERSION }} --output text --query 'images[].imageManifest')
          aws ecr put-image --repository-name ${{ vars.PINGPONG_SRV_REPO }} --registry-id ${{ env.REGISTRY_ID }} --image-tag ${{ env.ENVIRONMENT }} --image-manifest "$MANIFEST"
          echo "Tagged existing Server Image (${{ env.IMAGE_VERSION }}) with ${{ env.ENVIRONMENT }} tag"

      - name: Build server image for release
        env:
          ENVIRONMENT: ${{ github.event.release.prerelease && 'stage' || 'prod' }}
          SRV_VERSION: ${{ env.IMAGE_VERSION }}
        if: ${{ env.SRV_IMAGE_STATUS == 'DOES_NOT_EXIST' }}
        run: |
          echo "Building Server Image with tag ${{ env.IMAGE_VERSION }}"
          docker compose -f docker-compose.yml -f docker-compose.prod.yml build \
            --build-arg SENTRY_RELEASE=${{ env.RELEASE_VERSION }} \
            srv

      - name: Push server image for release
        env:
          ENVIRONMENT: ${{ github.event.release.prerelease && 'stage' || 'prod' }}
        if: ${{ env.SRV_IMAGE_STATUS == 'DOES_NOT_EXIST' }}
        run: |
          aws ecr get-login-password --region ${{ vars.AWS_REGION }} | docker login --username AWS --password-stdin ${{ vars.PINGPONG_REGISTRY_ENDPOINT }}
          docker tag ${{ vars.PINGPONG_SRV_REGISTRY }}:${{ env.IMAGE_VERSION }} ${{ vars.PINGPONG_SRV_REGISTRY }}:${{ env.ENVIRONMENT }}
          docker push ${{ vars.PINGPONG_SRV_REGISTRY }}:${{ env.IMAGE_VERSION }}
          docker push ${{ vars.PINGPONG_SRV_REGISTRY }}:${{ env.ENVIRONMENT }}
          echo "Built and pushed Server Image (${{ env.IMAGE_VERSION }}) with ${{ env.ENVIRONMENT }} tag"

      - name: Send Server Image tagged notification
        if: ${{ env.SRV_IMAGE_STATUS != 'EXISTS_WITH_ENV_TAG' }}
        env:
          SLACK_WEBHOOK: ${{ secrets.SLACK_WEBHOOK }}
          GIPHY_API_KEY: ${{ secrets.GIPHY_API_KEY }}
          ENVIRONMENT: ${{ github.event.release.prerelease && 'stage' || 'prod' }}
        run: |
          GIF=$(curl -s "https://api.giphy.com/v1/gifs/random?api_key=$GIPHY_API_KEY&tag=dog&rating=g" | python -c "import sys,json; print (json.load(sys.stdin)['data']['images']['downsized']['url'])")
          TAGGED_MSG=":pingpong: *Retagged* existing *Server Image (${{ env.IMAGE_VERSION }})* with *${{ env.ENVIRONMENT }}* tag :tada:"
          BUILT_MSG=":pingpong: *Built* and pushed *Server Image (${{ env.IMAGE_VERSION }})* with *${{ env.ENVIRONMENT }}* tag :tada:"
          if [[ ${{ env.SRV_IMAGE_STATUS }} == 'DOES_NOT_EXIST' ]]; then
            MSG=$BUILT_MSG
          else
            MSG=$TAGGED_MSG
          fi

          curl -X POST -H 'Content-Type: application/json' \
            --data "{\"text\": \"$MSG\", \"blocks\": [{\"type\":\"section\", \"text\": {\"type\": \"mrkdwn\", \"text\": \"$MSG\"}}, {\"type\":\"image\",\"image_url\":\"$GIF\", \"alt_text\":\"dog\", \"title\": {\"type\":\"plain_text\", \"text\": \"success dog\"}}]}" \
            $SLACK_WEBHOOK

      - name: Check if Web image exists
        env:
          ENVIRONMENT: ${{ github.event.release.prerelease && 'stage' || 'prod' }}
        run: |
          # Check if the image with version tag exists
          if aws ecr describe-images --repository-name ${{ vars.PINGPONG_WEB_REPO }} --registry-id ${{ env.REGISTRY_ID }} --image-ids imageTag=${{ env.IMAGE_VERSION }} >/dev/null 2>&1; then
            if grep -q ${{ env.ENVIRONMENT }} <<< $(aws ecr describe-images --repository-name ${{ vars.PINGPONG_WEB_REPO }} --registry-id ${{ env.REGISTRY_ID }} --image-ids imageTag=${{ env.IMAGE_VERSION }}); then
              echo "WEB_IMAGE_STATUS=EXISTS_WITH_ENV_TAG" >> $GITHUB_ENV
              echo "Web Image with tag ${{ env.IMAGE_VERSION }} exists and has the ${{ env.ENVIRONMENT }} tag in ECR."
            else
              echo "WEB_IMAGE_STATUS=EXISTS_WITHOUT_ENV_TAG" >> $GITHUB_ENV
              echo "Web Image with tag ${{ env.IMAGE_VERSION }} exists but does not have the ${{ env.ENVIRONMENT }} tag in ECR."
            fi
          else
            echo "WEB_IMAGE_STATUS=DOES_NOT_EXIST" >> $GITHUB_ENV
            echo "Web Image with tag ${{ env.IMAGE_VERSION }} does not exist in ECR."
          fi

        shell: bash

      - name: Tag web image for release
        env:
          ENVIRONMENT: ${{ github.event.release.prerelease && 'stage' || 'prod' }}
        if: ${{ env.WEB_IMAGE_STATUS  == 'EXISTS_WITHOUT_ENV_TAG' }}
        run: |
          MANIFEST=$(aws ecr batch-get-image --repository-name ${{ vars.PINGPONG_WEB_REPO }} --registry-id ${{ env.REGISTRY_ID }} --image-ids imageTag=${{ env.IMAGE_VERSION }} --output text --query 'images[].imageManifest')
          aws ecr put-image --repository-name ${{ vars.PINGPONG_WEB_REPO }} --registry-id ${{ env.REGISTRY_ID }} --image-tag ${{ env.ENVIRONMENT }} --image-manifest "$MANIFEST"
          echo "Tagged existing Web Image (${{ env.IMAGE_VERSION }}) with ${{ env.ENVIRONMENT }} tag"

      - name: Build web image for release
        env:
          ENVIRONMENT: ${{ github.event.release.prerelease && 'stage' || 'prod' }}
          WEB_VERSION: ${{ env.IMAGE_VERSION }}
        if: ${{ env.WEB_IMAGE_STATUS == 'DOES_NOT_EXIST' }}
        run: |
          echo "Building Web Image with tag ${{ env.IMAGE_VERSION }}"
          docker compose -f docker-compose.yml -f docker-compose.prod.yml build web

      - name: Push web image for release
        env:
          ENVIRONMENT: ${{ github.event.release.prerelease && 'stage' || 'prod' }}
        if: ${{ env.WEB_IMAGE_STATUS == 'DOES_NOT_EXIST' }}
        run: |
          aws ecr get-login-password --region ${{ vars.AWS_REGION }} | docker login --username AWS --password-stdin ${{ vars.PINGPONG_REGISTRY_ENDPOINT }}
          docker tag ${{ vars.PINGPONG_WEB_REGISTRY }}:${{ env.IMAGE_VERSION }} ${{ vars.PINGPONG_WEB_REGISTRY }}:${{ env.ENVIRONMENT }}
          docker push ${{ vars.PINGPONG_WEB_REGISTRY }}:${{ env.IMAGE_VERSION }}
          docker push ${{ vars.PINGPONG_WEB_REGISTRY }}:${{ env.ENVIRONMENT }}
          echo "Built and pushed Web Image (${{ env.IMAGE_VERSION }}) with ${{ env.ENVIRONMENT }} tag"

      - name: Send Web Image tagged notification
        if: ${{ env.WEB_IMAGE_STATUS != 'EXISTS_WITH_ENV_TAG' }}
        env:
          SLACK_WEBHOOK: ${{ secrets.SLACK_WEBHOOK }}
          GIPHY_API_KEY: ${{ secrets.GIPHY_API_KEY }}
          ENVIRONMENT: ${{ github.event.release.prerelease && 'stage' || 'prod' }}
        run: |
          GIF=$(curl -s "https://api.giphy.com/v1/gifs/random?api_key=$GIPHY_API_KEY&tag=cat&rating=g" | python -c "import sys,json; print (json.load(sys.stdin)['data']['images']['downsized']['url'])")
          TAGGED_MSG=":pingpong: *Retagged* existing *Web Image (${{ env.IMAGE_VERSION }})* with *${{ env.ENVIRONMENT }}* tag :tada:"
          BUILT_MSG=":pingpong: *Built* and pushed *Web Image (${{ env.IMAGE_VERSION }})* with *${{ env.ENVIRONMENT }}* tag :tada:"
          if [[ ${{ env.WEB_IMAGE_STATUS }} == 'DOES_NOT_EXIST' ]]; then
            MSG=$BUILT_MSG
          else
            MSG=$TAGGED_MSG
          fi

          curl -X POST -H 'Content-Type: application/json' \
            --data "{\"text\": \"$MSG\", \"blocks\": [{\"type\":\"section\", \"text\": {\"type\": \"mrkdwn\", \"text\": \"$MSG\"}}, {\"type\":\"image\",\"image_url\":\"$GIF\", \"alt_text\":\"dog\", \"title\": {\"type\":\"plain_text\", \"text\": \"success cat\"}}]}" \
            $SLACK_WEBHOOK

      - name: Create Sentry release
        uses: getsentry/action-release@v3
        env:
          SENTRY_AUTH_TOKEN: ${{ secrets.SENTRY_AUTH_TOKEN }}
          SENTRY_ORG: ${{ vars.SENTRY_ORG }}
          SENTRY_PROJECT: ${{ github.event.release.prerelease && vars.SENTRY_PROJECT_STAGE || vars.SENTRY_PROJECT_PROD }}
        with:
          environment: ${{ github.event.release.prerelease && 'staging' || 'production' }}
          version: ${{ env.RELEASE_VERSION }}
          set_commits: auto
